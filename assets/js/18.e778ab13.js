(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{606:function(s,a,t){"use strict";t.r(a);var e=t(5),n=Object(e.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p",[s._v("如果用过 Node.js, 那一定用过 npm, 但 npx 又是什么呢？")]),s._v(" "),t("h2",{attrs:{id:"npm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#npm"}},[s._v("#")]),s._v(" npm")]),s._v(" "),t("p",[s._v("npm 是随 Node.js 一同安装的包管理工具, 通过它可本地或全局安装依赖库并管理其版本。")]),s._v(" "),t("p",[s._v("npm 本身不会运行任何库, 当 npm 执行安装库的指令时(npm install xxx), npm 会创建指向它们的链接:")]),s._v(" "),t("ol",[t("li",[s._v("全局安装会在全局安装的 npm 文件夹下创建链接, 可以用 "),t("code",[s._v("npm root -g")]),s._v(" 命令来查看 npm 所在文件夹,\nnpm 安装时会自动配置 $PATH 环境变量, 指向 npm 所在文件夹, 所以通过 npm 安装某些命令行工具时,\n只有全局安装终端才能识别相应命令, 局部安装识别不了。")]),s._v(" "),t("li",[s._v("局部安装会在工程目录的 "),t("code",[s._v("./node_modules/.bin/")]),s._v(" 文件夹中创建链接")])]),s._v(" "),t("p",[s._v("当需要执行库时, 全局安装时终端能识别相应指令, 但局部安装的却有些繁琐:")]),s._v(" "),t("ol",[t("li",[s._v("可以直接使用相对路径来调用安装的包")])]),s._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("./node_modules/.bin/your-package\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[s._v("在 package.json 文件中添加脚本, 如")])]),s._v(" "),t("div",{staticClass:"language-json extra-class"},[t("pre",{pre:!0,attrs:{class:"language-json"}},[t("code",[t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token property"}},[s._v('"name"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"webpack-demo"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token property"}},[s._v('"version"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"1.0.0"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token property"}},[s._v('"scripts"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token property"}},[s._v('"your-package"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"your-package"')]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),t("p",[s._v("然后运行指令")]),s._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[s._v("npm")]),s._v(" run your-package\n")])])]),t("p",[s._v("这两种方式实际上是一样的, 只是 npm run 会自动添加 "),t("code",[s._v("./node_module/.bin/")])]),s._v(" "),t("p",[s._v("只凭借 npm, 如果想要运行某些库, 不安装是不行的 😑 😑 😑")]),s._v(" "),t("h2",{attrs:{id:"npx"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#npx"}},[s._v("#")]),s._v(" npx")]),s._v(" "),t("p",[s._v("npm 从 5.2 版本开始, 增加了 npx 命令, 它是一个 npm 包的执行器 😍 😍 😍")]),s._v(" "),t("p",[s._v("只要 npm 的版本在 5.2 以上可直接使用 npx 命令, 万一不能用, 建议升级一下 Node 版本, 也可直接安装 npx")]),s._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[s._v("npm")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("install")]),s._v(" npx -g\n")])])]),t("div",{staticClass:"custom-block danger"},[t("p",{staticClass:"title"}),t("p",[s._v("npx 的原理很简单, 在运行的时候, 首先会检查工程目录 "),t("code",[s._v("./node_modules/.bin")]),s._v(" 路径, 再检查环境变量 "),t("code",[s._v("$PATH")]),s._v(" 查看命令是否存在,\n如果存在则会使用相应的本地模块, 当这两个路径都不能找到相应命令时, 会下载远程模块至临时目录, 在使用完毕之后删除。")])]),t("p",[s._v("由于 npx 会检查环境变量 "),t("code",[s._v("$PATH")]),s._v(", 所以系统命令也可以调用")]),s._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 等同于 ls")]),s._v("\nnpx "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("ls")]),s._v("\n")])])]),t("p",[s._v("需要注意的是, Bash 内置的命令不在 "),t("code",[s._v("$PATH")]),s._v(" 里, 所以不能用。比如, "),t("code",[s._v("cd")]),s._v(" 是 Bash 命令, 因此不能用 "),t("code",[s._v("npx cd")])]),s._v(" "),t("p",[s._v("利用 npx, 可以临时安装可执行依赖包, 不用全局安装, 避免全局污染, 例如在本地没有安装 "),t("code",[s._v("http-server")]),s._v(" 模块的情况下,\n可以随时启动一个 Web 服务 🐂 🐃 🐄")]),s._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("npx http-server\n")])])]),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"title"}),t("p",[s._v("如果想让 npx 强制使用本地模块, 不下载远程模块, 可以使用 "),t("code",[s._v("--no-install")]),s._v(" 参数。如果本地不存在该模块, 就会报错。")]),s._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("npx --no-install http-server\n")])])]),t("p",[s._v("反过来, 如果想忽略本地模块, 强制使用安装远程模块, 可以使用 "),t("code",[s._v("--ignore-existing")]),s._v(" 参数。")]),s._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("npx --ignore-existing create-react-app my-react-app\n")])])])]),t("h3",{attrs:{id:"使用不同版本的node"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用不同版本的node"}},[s._v("#")]),s._v(" 使用不同版本的node")]),s._v(" "),t("p",[s._v("利用 npx 可以下载模块的特点, 还可以指定某个版本的 Node 运行脚本, 在某些场景下, 可利用它切换 Node 版本")]),s._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("npx node@17.7.2 -v\n")])])]),t("h3",{attrs:{id:"安装多模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装多模块"}},[s._v("#")]),s._v(" 安装多模块")]),s._v(" "),t("p",[s._v("npx 的 "),t("code",[s._v("-p")]),s._v(" 参数用于指定 npx 所要安装的模块, 对于需要安装多个模块的场景很有用")]),s._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("npx -p lolcatjs -p cowsay "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("command"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\nnpx -p node@17.7.2 "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("node")]),s._v(" -v\n")])])]),t("h3",{attrs:{id:"运行多指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运行多指令"}},[s._v("#")]),s._v(" 运行多指令")]),s._v(" "),t("p",[s._v("在安装多模块时, 默认情况下, 只有第一个可执行项会使用 npx 安装的模块, 后面的可执行项还是会交给 Shell 解释。")]),s._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("npx -p lolcatjs -p cowsay "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'cowsay hello | lolcatjs'")]),s._v("       "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 报错")]),s._v("\n")])])]),t("p",[s._v("上面代码中, "),t("code",[s._v("cowsay hello | lolcatjs")]),s._v(" 执行时会报错, 原因是第一项 "),t("code",[s._v("cowsay")]),s._v(" 由 npx 解释, 而第二项命令 "),t("code",[s._v("lolcatjs")]),s._v(" 由 Shell 解释,\n但是 "),t("code",[s._v("lolcatjs")]),s._v(" 并没有全局安装, 所以报错。")]),s._v(" "),t("p",[t("code",[s._v("-c")]),s._v(" 参数可以将所有的命令都用 npx 解释")]),s._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("npx -p lolcatjs -p cowsay -c "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'cowsay hello | lolcatjs'")]),s._v("\n")])])]),t("h3",{attrs:{id:"执行github源码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行github源码"}},[s._v("#")]),s._v(" 执行github源码")]),s._v(" "),t("p",[s._v("npx 还可以执行 Github 上面的模块代码, 但需要注意的是, 远程代码必须是一个模块, 即必须包含 "),t("code",[s._v("package.json")]),s._v(" 和 入口脚本")]),s._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("npx github地址\n")])])]),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),t("p",[s._v("npx 是一个 npm 包的执行器, 在运行的时候, 首先会检查工程目录 "),t("code",[s._v("./node_modules/.bin")]),s._v(" 路径, 再检查环境变量 "),t("code",[s._v("$PATH")]),s._v(" 查看命令是否存在,\n如果存在则会使用相应的本地模块, 当这两个路径都不能找到相应命令时, 会下载远程模块至临时目录, 在使用完毕之后删除。")])])}),[],!1,null,null,null);a.default=n.exports}}]);