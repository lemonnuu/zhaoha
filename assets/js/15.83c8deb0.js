(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{600:function(e,t,a){"use strict";a.r(t);var n=a(5),v=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("DOM 表示由多层节点构成的文档, 通过它开发者可以添加、删除和修改页面的各个部分。")]),e._v(" "),a("p",[e._v("任何 HTML 或 XML 文档都可以用 DOM 表示为一个由节点构成的层级结构, 节点分为很多类型")]),e._v(" "),a("p",[e._v("document 节点表示每个文档的根节点, 根节点唯一子节点是 "),a("code",[e._v("<html>")]),e._v(" 元素, 我们称之为文档元素")]),e._v(" "),a("p",[e._v("实时的活动对象，第一次访问时的快照")]),e._v(" "),a("h2",{attrs:{id:"node-类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node-类型"}},[e._v("#")]),e._v(" Node 类型")]),e._v(" "),a("p",[e._v("DOM 中共有 12 种节点类型")]),e._v(" "),a("h3",{attrs:{id:"nodename-与-nodevalue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nodename-与-nodevalue"}},[e._v("#")]),e._v(" nodeName 与 nodeValue")]),e._v(" "),a("p",[e._v("nodeName 和 nodeValue 保存着有关节点的信息, 但这两个属性的值完全取决于节点类型,\n在使用这两个属性前, 最好先检测一哈节点类型")]),e._v(" "),a("p",[e._v("对元素节点来说, nodeName 始终等于元素的标签名, nodeValue 始终是 null")]),e._v(" "),a("h3",{attrs:{id:"节点关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#节点关系"}},[e._v("#")]),e._v(" 节点关系")]),e._v(" "),a("p",[e._v("每个节点都有一个 childNodes 属性, 其中包含一个 NodeList 的实例,\nNodeList 是一个类数组对象, 用于存储可以按位置存取的有序节点。")]),e._v(" "),a("p",[e._v("NodeList 的独特之处就在于, 他其实是一个对 DOM 结构的查询,\n因此 DOM 结构的变化会自动地在 NodeList 中反映出来。\n我们通常说 NodeList 是实时的活动对象, 而不是第一次访问时所获得内容快照。")]),e._v(" "),a("p",[e._v("每个节点都有一个 parentNode 属性, 指向其 DOM 树中的父元素")]),e._v(" "),a("p",[e._v("childNodes, parentNode, previousSibling, nextSibling, firstChild, lastChild\n第一个子节点的 previousSibling 是 null\n最后一个子节点的 nextSibling 是 null")]),e._v(" "),a("p",[e._v("hasChildNodes() 返回 true, 代表有子节点, childNodes.length 也可以判断")]),e._v(" "),a("h3",{attrs:{id:"操纵节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#操纵节点"}},[e._v("#")]),e._v(" 操纵节点")]),e._v(" "),a("p",[e._v("appendChild(), 用于在 childNodes 列表末尾添加节点, 返回新添加的节点")]),e._v(" "),a("p",[e._v("如果把文档中已经存在的节点传给 appendChild(), 则这个节点会从之前的位置被转移到新位置")]),e._v(" "),a("p",[e._v("即使 DOM 树通过各种关系指针维系, 一个节点也不会同时出现在两个或更多地方,\n因此，如果调用 appendChild() 传入父元素的第一个子节点, 则这个元素会成为父元素的最后一个子节点")]),e._v(" "),a("p",[e._v("如果要把节点放到 childNodes 中的特定位置而不是末尾, 则可以使用 insertBefore() 方法,\n这个方法接收两个参数, 要插入的节点和参照节点,\n调用这个方法后, 要插入的节点会变成参照节点的前一个同胞节点, 并被返回,\n如果参照节点是 null, 则 insertBefore() 与 appendChild() 效果相同")]),e._v(" "),a("p",[e._v("replaceChild() 方法接收两个参数, 要插入的节点和替换的节点,\n要替换的节点会被返回并从文档树中完全移除, 要插入的节点取而代之,\n虽然被替换的节点从技术上来说仍然被同一个文档所拥有, 但文档中已经没有了它的位置")]),e._v(" "),a("p",[e._v("removeChild() 接收一个参数, 即要移除的节点")]),e._v(" "),a("p",[e._v("cloneNode(), 会返回与调用它的节点一模一样的节点,\n接收一个布尔值参数, 表示是否深复制, 在传入 true 时, 会进行深复制,\n只会复制 HTML 属性, 不会复制事件处理程序")]),e._v(" "),a("p",[e._v("normalize()")]),e._v(" "),a("h2",{attrs:{id:"document-类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#document-类型"}},[e._v("#")]),e._v(" Document 类型")]),e._v(" "),a("p",[e._v("document 是 window 对象的属性, 因此是一个全局对象, document 只能有一个 Element 类型的子节点, 即 html")]),e._v(" "),a("p",[e._v("nodeType = 9,\nnodeName = '#document'")]),e._v(" "),a("h3",{attrs:{id:"访问-html-body"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#访问-html-body"}},[e._v("#")]),e._v(" 访问 html, body")]),e._v(" "),a("p",[e._v("document 上有一个属性 documentElement, 指向 "),a("code",[e._v("<html>")]),e._v(" 元素")]),e._v(" "),e._v(" 没有用, 不准的, 得按照规矩来\n"),a("ul",[a("li",[e._v("document.documentElement")])]),e._v(" "),a("p",[e._v("document 上还有一个属性 body, 指向 "),a("code",[e._v("<body>")]),e._v(" 元素")]),e._v(" "),a("ul",[a("li",[e._v("document.body")])]),e._v(" "),a("h3",{attrs:{id:"访问-doctype"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#访问-doctype"}},[e._v("#")]),e._v(" 访问 doctype")]),e._v(" "),a("p",[e._v("Document 类型的另一种可能的子节点是 DocumentType, "),a("code",[e._v("<!doctype>")]),e._v(" 标签是文档中独立的部分")]),e._v(" "),a("ul",[a("li",[e._v("document.doctype")])]),e._v(" "),a("h3",{attrs:{id:"comment-类型子节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#comment-类型子节点"}},[e._v("#")]),e._v(" Comment 类型子节点")]),e._v(" "),a("p",[e._v("严格来说出现在 "),a("code",[e._v("<html>")]),e._v(" 元素外面的注释也是文档的子节点, 它们的类型是 Comment,\n不过由于浏览器识别不同, 这些注释不一定能够被识别, 或者表现不一致")]),e._v(" "),a("p",[e._v("一般来说, appendChild(), removeChild(), replaceChild() 方法不会用在 document 对象上,\n这是因为文档类型(如果存在)是只读的, 而且只能有 Element 类型的子节点(即 html)")]),e._v(" "),a("h3",{attrs:{id:"文档信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文档信息"}},[e._v("#")]),e._v(" 文档信息")]),e._v(" "),a("h4",{attrs:{id:"title"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#title"}},[e._v("#")]),e._v(" title")]),e._v(" "),a("p",[e._v("document.title 包含 "),a("code",[e._v("<title>")]),e._v(" 元素中的文本, 通常显示在浏览器窗口或标签页的标题栏,\n通过这个属性可以读写页面的标题, 修改后的标题也会反映在浏览器标题栏上,\n不过, 修改 title 属性并不会改变 "),a("code",[e._v("title")]),e._v(" 元素")]),e._v(" "),a("h4",{attrs:{id:"url-domain-referrer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#url-domain-referrer"}},[e._v("#")]),e._v(" URL, domain, referrer")]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[e._v("document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[e._v("URL")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 取得完整的URL")]),e._v("\ndocument"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("domain "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 包含网页的域名")]),e._v("\ndocument"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("referrer "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 包含链接到当前网页的那个页面的 URL, 取得来源, 如果当前网页没有来源, 则 referrer 属性包含空字符串")]),e._v("\n")])])]),a("p",[e._v("URL 跟域名是相关的, 比如 document.URL 是 http://www.wrox.com/WilerCDA/, document.domain 就是 www.wrox.com")]),e._v(" "),a("p",[e._v("在这些属性中, 只有 domain 是可以设置的,\n出于安全考虑, 给 domain 属性设置的值是有限的,\n只能设置 父域, 不能给这个属性设置 URL 中不包含的值")]),e._v(" "),a("p",[e._v("当网页中包含来自某个不同子域的窗格("),a("code",[e._v("<frame>")]),e._v(")或内嵌窗格("),a("code",[e._v("<iframe>")]),e._v(")时, 设置document.domain 是很有用的")]),e._v(" "),a("h3",{attrs:{id:"定位元素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定位元素"}},[e._v("#")]),e._v(" 定位元素")]),e._v(" "),a("p",[e._v("document.getElementById()\ndocument.getElementByTagName()")]),e._v(" "),a("p",[e._v("这里要深究几个问题哈,\n一个是 HTML 对大小写不敏感的问题\n这几个方法是不是document特有 (ById, ByName 是特有的好像)")]),e._v(" "),a("h3",{attrs:{id:"文档写入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文档写入"}},[e._v("#")]),e._v(" 文档写入")]),e._v(" "),a("p",[e._v("write(), writeln() 用于动态包含外部资源")])])}),[],!1,null,null,null);t.default=v.exports}}]);